<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rolling Ball Mine</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #0f162e;
      --text: #e8ecff;
      --accent: #6aa6ff;
      --danger: #ff4d6d;
      --success: #3ad29f;
    }
    html, body { height: 100%; }
    body {
      margin: 0; background: radial-gradient(1200px 800px at 70% -10%, #142042, var(--bg));
      color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Kufi Arabic", sans-serif;
      display: grid; place-items: center;
    }
    .wrap { width: min(1000px, 96vw); }
    header {
      display: flex; align-items: center; justify-content: space-between; gap: 12px;
      margin-bottom: 10px; padding: 10px 14px; border-radius: 16px;
      background: linear-gradient(180deg, #101a39, #0b132b);
      box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.05);
    }
    header h1 { font-size: 20px; font-weight: 700; letter-spacing: .2px; margin: 0; }
    header .btns { display: flex; gap: 8px; align-items: center; }
    button, .chip {
      border: 0; border-radius: 999px; padding: 10px 14px; font-weight: 600; cursor: pointer;
      background: #182347; color: var(--text);
      box-shadow: 0 8px 20px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.07);
      transition: transform .08s ease, background .2s ease, opacity .2s ease;
    }
    button:hover { transform: translateY(-1px); }
    button:active { transform: translateY(0px) scale(.98); }
    .primary { background: linear-gradient(135deg, #3f70ff, #7aa8ff); color: #fff; }
    .ghost { background: transparent; outline: 1px solid #2a3560; }
    .chip { font-size: 14px; opacity: .9; }

    #hud { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    #score, #best { background: #13204b; padding: 8px 12px; border-radius: 10px; font-feature-settings: "tnum" 1; }

    canvas { display: block; width: 100%; height: auto; border-radius: 22px; background: #0a0f1f; }

    .overlay {
      position: absolute; inset: 0; display: grid; place-items: center;
      pointer-events: none;
    }
    .card {
      pointer-events: auto;
      background: linear-gradient(180deg, #0e1633, #0a1128);
      border: 1px solid #1d2855; border-radius: 20px; padding: 22px; width: min(520px, 92vw);
      box-shadow: 0 20px 40px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.06);
      text-align: center;
    }
    .card h2 { margin: 0 0 8px; font-size: 24px; }
    .card p { margin: 0 0 14px; color: #c9d4ff; opacity: .9; }
    .kbd { display: inline-block; padding: 3px 8px; border-radius: 6px; background:#14214e; border:1px solid #2a3a7e; font-weight:700 }

    .touch { position: absolute; inset: auto 16px 16px auto; display:flex; gap:8px; }
    .stick, .jump {
      width: 84px; height: 84px; border-radius: 18px; background: #121a3a; border: 1px solid #27346a;
      display: grid; place-items: center; backdrop-filter: blur(6px);
    }
    .jump { width: 48px; height: 48px; align-self: end; }
    .dot { width: 28px; height: 28px; border-radius: 50%; background: #3e6bff; opacity:.85 }

    footer { margin-top: 10px; text-align: center; opacity: .8; font-size: 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>🎮 Rolling Ball Mine</h1>
      <div class="btns" id="hud">
        <span class="chip">⬅️➡️ WASD / الأسهم</span>
        <div id="score">النتيجة: 0</div>
        <div id="best">أفضل رقم: 0</div>
        <button id="mute" class="ghost" aria-label="Toggle sound">🔈 صوت</button>
        <button id="restart" class="primary">إعادة</button>
      </div>
    </header>

    <div style="position:relative">
      <canvas id="game" width="960" height="540" aria-label="ساحة اللعب"></canvas>
      <div class="overlay" id="startOverlay">
        <div class="card">
          <h2>تفادى الألغام وابقَ حيًّا! 💣</h2>
          <p>حرّك الكرة واجمع النقاط بمرور الوقت. إذا لمست لغمًا تنتهي الجولة.</p>
          <p>التحكم: <span class="kbd">WASD</span> أو <span class="kbd">الأسهم</span> — قفزة خفيفة بـ <span class="kbd">Space</span></p>
          <button id="start" class="primary">ابدأ الآن</button>
        </div>
      </div>
      <div class="touch" id="touchCtl" hidden>
        <div class="stick"><div class="dot" id="stickDot"></div></div>
        <button class="jump" id="jumpBtn">⤴︎</button>
      </div>
    </div>

    <footer>صُمّم بواجهات HTML5 Canvas • فيزياء بسيطة واصطدامات دقيقة</footer>
  </div>

  <audio id="hitSnd" preload="auto">
    <source src="data:audio/wav;base64,UklGRlQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABYAZGF0YVQAAAAA/////wAAAP///wAAAP///wAAAP///wAA" type="audio/wav">
  </audio>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const HUD = {
      score: document.getElementById('score'),
      best: document.getElementById('best'),
      mute: document.getElementById('mute'),
      restart: document.getElementById('restart')
    };

    const SND = { hit: document.getElementById('hitSnd'), muted: false };

    // Utilities
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rnd = (a, b) => Math.random() * (b - a) + a;

    let W = canvas.width, H = canvas.height;
    const DPR = Math.min(2, window.devicePixelRatio || 1);
    function resize() {
      const rect = canvas.getBoundingClientRect();
      W = Math.floor(rect.width * DPR);
      H = Math.floor((rect.width * 9/16) * DPR);
      if (H > Math.floor((window.innerHeight - 200) * DPR)) H = Math.floor((window.innerHeight - 200) * DPR);
      canvas.width = W; canvas.height = H;
    }
    resize();
    window.addEventListener('resize', resize);

    // Game state
    const state = {
      running: false,
      score: 0,
      best: Number(localStorage.getItem('rbm_best')||0),
      t: 0,
      mines: [],
      particles: [],
    };

    const player = {
      x: W/2, y: H/2, r: 16,
      vx: 0, vy: 0,
      angle: 0,
      speed: 0.45,
      maxSpd: 4.2,
      friction: 0.985,
      bounce: 0.55,
    };

    const input = { up:false, down:false, left:false, right:false, jump:false };

    // Touch controls
    const touchCtl = document.getElementById('touchCtl');
    const stickDot = document.getElementById('stickDot');
    const jumpBtn = document.getElementById('jumpBtn');
    function setupTouch() {
      const isTouch = matchMedia('(pointer:coarse)').matches;
      touchCtl.hidden = !isTouch;
      if (!isTouch) return;
      let origin = null;
      const stick = touchCtl.querySelector('.stick');
      stick.addEventListener('touchstart', e=>{
        origin = { x:e.touches[0].clientX, y:e.touches[0].clientY };
      });
      stick.addEventListener('touchmove', e=>{
        if(!origin) return;
        const dx = e.touches[0].clientX - origin.x;
        const dy = e.touches[0].clientY - origin.y;
        const mag = Math.hypot(dx,dy);
        const max = 30;
        const nx = clamp(dx, -max, max), ny = clamp(dy, -max, max);
        stickDot.style.transform = `translate(${nx}px, ${ny}px)`;
        input.left = nx < -10; input.right = nx > 10;
        input.up = ny < -10; input.down = ny > 10;
      });
      const resetStick = ()=>{
        origin = null; stickDot.style.transform = 'translate(0,0)';
        input.left = input.right = input.up = input.down = false;
      };
      stick.addEventListener('touchend', resetStick);
      stick.addEventListener('touchcancel', resetStick);
      jumpBtn.addEventListener('touchstart', ()=>{ input.jump = true; });
      jumpBtn.addEventListener('touchend', ()=>{ input.jump = false; });
    }
    setupTouch();

    // Keyboard
    const map = { ArrowUp:'up', ArrowDown:'down', ArrowLeft:'left', ArrowRight:'right', w:'up', s:'down', a:'left', d:'right' };
    window.addEventListener('keydown', e=>{
      const k = map[e.key]; if(k){ input[k]=true; }
      if(e.code==='Space'){ input.jump = true; }
      if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
    }, { passive:false });
    window.addEventListener('keyup', e=>{
      const k = map[e.key]; if(k){ input[k]=false; }
      if(e.code==='Space'){ input.jump = false; }
    });

    // Mines
    function spawnMine() {
      const margin = 40;
      let x, y;
      do {
        x = rnd(margin, W - margin);
        y = rnd(margin, H - margin);
      } while (Math.hypot(x - player.x, y - player.y) < 120);
      const r = rnd(10, 20);
      const ang = rnd(0, Math.PI*2);
      const spd = rnd(0.4, 1.4) + Math.min(1.8, state.t/20000);
      state.mines.push({ x, y, r, vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd, pulse: rnd(0, 6.28) });
    }

    function burst(x,y,color,count=18) {
      for(let i=0;i<count;i++){
        const a = rnd(0, Math.PI*2), s = rnd(1,4);
        state.particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s, life: rnd(400,900), color });
      }
    }

    // Drawing helpers
    function drawBall(p) {
      const g = ctx.createLinearGradient(p.x-p.r, p.y-p.r, p.x+p.r, p.y+p.r);
      g.addColorStop(0, '#6ca8ff');
      g.addColorStop(1, '#2f58ff');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
      // stripe to show rolling
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.angle);
      ctx.strokeStyle = 'rgba(255,255,255,.7)';
      ctx.lineWidth = 3 * DPR;
      ctx.beginPath();
      ctx.moveTo(-p.r*0.9, 0);
      ctx.lineTo(p.r*0.9, 0);
      ctx.stroke();
      ctx.restore();
      // subtle shadow
      ctx.fillStyle = 'rgba(0,0,0,.25)';
      ctx.beginPath(); ctx.ellipse(p.x+2, p.y+6, p.r*0.9, p.r*0.5, 0, 0, Math.PI*2); ctx.fill();
    }

    function drawMine(m) {
      m.pulse += 0.05;
      const glow = 6 + Math.sin(m.pulse) * 2;
      ctx.shadowColor = '#ff5577';
      ctx.shadowBlur = glow * DPR;
      ctx.fillStyle = '#ff355e';
      ctx.beginPath(); ctx.arc(m.x, m.y, m.r, 0, Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;
      // cross mark
      ctx.strokeStyle = '#ffd2dc';
      ctx.lineWidth = 2 * DPR;
      ctx.beginPath(); ctx.moveTo(m.x-m.r*0.6, m.y-m.r*0.6); ctx.lineTo(m.x+m.r*0.6, m.y+m.r*0.6); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(m.x+m.r*0.6, m.y-m.r*0.6); ctx.lineTo(m.x-m.r*0.6, m.y+m.r*0.6); ctx.stroke();
    }

    function drawParticles(dt) {
      for(let i=state.particles.length-1;i>=0;i--){
        const p = state.particles[i];
        p.life -= dt; if(p.life <= 0){ state.particles.splice(i,1); continue; }
        p.x += p.vx; p.y += p.vy; p.vy += 0.005 * dt;
        ctx.globalAlpha = Math.max(0, p.life/900);
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 2*DPR, 2*DPR);
        ctx.globalAlpha = 1;
      }
    }

    // Physics & update
    let last = performance.now();
    function step(now) {
      const dt = now - last; last = now;
      if (!state.running) { requestAnimationFrame(step); return; }
      state.t += dt; state.score += dt * 0.01; // ~1 point per 100ms

      // Difficulty ramp: spawn mine based on time & cap
      const desired = Math.min(25, 3 + Math.floor(state.t / 4000));
      while (state.mines.length < desired) spawnMine();

      // Input -> acceleration
      let ax = 0, ay = 0;
      if (input.left) ax -= player.speed;
      if (input.right) ax += player.speed;
      if (input.up) ay -= player.speed;
      if (input.down) ay += player.speed;

      // Jump gives a quick impulse (fake Z)
      if (input.jump) { ay -= 0.35; input.jump = false; }

      player.vx += ax; player.vy += ay;
      const spd = Math.hypot(player.vx, player.vy);
      if (spd > player.maxSpd) { const k = player.maxSpd / spd; player.vx *= k; player.vy *= k; }
      player.x += player.vx; player.y += player.vy;
      player.vx *= player.friction; player.vy *= player.friction;
      player.angle += spd * 0.08;

      // Walls
      if (player.x < player.r) { player.x = player.r; player.vx = -player.vx * player.bounce; }
      if (player.x > W - player.r) { player.x = W - player.r; player.vx = -player.vx * player.bounce; }
      if (player.y < player.r) { player.y = player.r; player.vy = -player.vy * player.bounce; }
      if (player.y > H - player.r) { player.y = H - player.r; player.vy = -player.vy * player.bounce; }

      // Mines movement + bounce on walls
      for (const m of state.mines) {
        m.x += m.vx; m.y += m.vy;
        if (m.x < m.r || m.x > W - m.r) m.vx *= -1;
        if (m.y < m.r || m.y > H - m.r) m.vy *= -1;
      }

      // Collisions
      for (const m of state.mines) {
        const d = Math.hypot(player.x - m.x, player.y - m.y);
        if (d < player.r + m.r) {
          gameOver(m);
          break;
        }
      }

      // Rendering
      ctx.clearRect(0, 0, W, H);
      // background grid
      ctx.save();
      ctx.globalAlpha = 0.12;
      ctx.strokeStyle = '#7aa1ff';
      ctx.lineWidth = 1 * DPR;
      const grid = 40 * DPR;
      for (let x = (state.t*0.03)%grid; x < W; x += grid) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
      for (let y = (state.t*0.02)%grid; y < H; y += grid) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
      ctx.restore();

      // draw entities
      for (const m of state.mines) drawMine(m);
      drawBall(player);
      drawParticles(dt);

      HUD.score.textContent = `النتيجة: ${Math.floor(state.score)}`;

      requestAnimationFrame(step);
    }

    function resetGame() {
      state.running = false;
      state.score = 0; state.t = 0; state.mines = []; state.particles = [];
      player.x = W/2; player.y = H/2; player.vx = player.vy = 0; player.angle = 0;
      HUD.score.textContent = `النتيجة: 0`;
      document.getElementById('startOverlay').style.display = 'grid';
    }

    function startGame() {
      document.getElementById('startOverlay').style.display = 'none';
      state.running = true; last = performance.now(); requestAnimationFrame(step);
    }

    function gameOver(mine) {
      state.running = false;
      burst(player.x, player.y, '#ffffff', 50);
      burst(mine.x, mine.y, '#ff6b8a', 40);
      if (!SND.muted) { try{ SND.hit.currentTime = 0; SND.hit.play(); }catch(_){} }
      state.best = Math.max(state.best, Math.floor(state.score));
      localStorage.setItem('rbm_best', String(state.best));
      HUD.best.textContent = `أفضل رقم: ${state.best}`;
      setTimeout(()=>{
        document.getElementById('startOverlay').style.display = 'grid';
        const card = document.querySelector('.card');
        card.querySelector('h2').textContent = 'انتهت الجولة!';
        card.querySelector('p').innerHTML = `درجتك: <strong>${Math.floor(state.score)}</strong>. اضغط \u201Cابدأ الآن\u201D للمحاولة مجددًا.`;
      }, 300);
    }

    // UI handlers
    document.getElementById('start').addEventListener('click', startGame);
    HUD.restart.addEventListener('click', ()=>{ resetGame(); startGame(); });
    HUD.mute.addEventListener('click', ()=>{
      SND.muted = !SND.muted; HUD.mute.textContent = SND.muted ? '🔇 صامت' : '🔈 صوت';
    });

    // Init
    HUD.best.textContent = `أفضل رقم: ${state.best}`;
    requestAnimationFrame(step);
  </script>
</body>
</html>
